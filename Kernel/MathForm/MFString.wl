(* ::Package:: *)

(* ::Section:: *)
(*Begin*)


BeginPackage["Yurie`MathForm`MFString`"];


Needs["Yurie`MathForm`"];

Needs["Yurie`MathForm`Constant`"];

Needs["Yurie`MathForm`Variable`"];


(* ::Section:: *)
(*Public*)


MFString::usage =
    "refine the string from TeXForm.";


MFStringKernel;

MFFormatKernel;


(* ::Section:: *)
(*Private*)


(* ::Subsection:: *)
(*Begin*)


Begin["`Private`"];


(* ::Subsection:: *)
(*Constant*)


$leftBracketP::usage =
    "pattern of left bracket.";

$rightBracketP::usage =
    "pattern of right bracket.";

$leftSeparatorP::usage =
    "pattern of left separator.";

$rightSeparatorP::usage =
    "pattern of right separator.";


$leftBracketP = "("|"["|"\\{"|"\\left("|"\\left["|"\\left\\{"|"{"|StartOfString;

$rightBracketP = ")"|"]"|"\\}"|"\\right)"|"\\right]"|"\\right\\}"|"}"|EndOfString;

$leftSeparatorP = "("|"["|"\\{"|"\\left("|"\\left["|"\\left\\{"|"{"|","|";"|"."|StartOfString;

$rightSeparatorP = ")"|"]"|"\\}"|"\\right)"|"\\right]"|"\\right\\}"|"}"|","|";"|"."|EndOfString;


(* ::Subsection:: *)
(*Option*)


MFStringKernel//Options = {
    "RemoveLeftRightPair"->True,
    "Linebreak"->True,
    "LinebreakThreshold"->6,
    "LinebreakIgnore"->{}
};

MFString//Options =
    Options@MFStringKernel;


(* ::Subsection:: *)
(*Main*)


MFString[expr_,opts:OptionsPattern[]] :=
    MFStringKernel[expr,FilterRules[{opts,Options@MFString},Options@MFStringKernel]]//
        MFFormatKernel//Catch;


MFStringKernel[string_String,OptionsPattern[]] :=
    string;

MFStringKernel[expr_,OptionsPattern[]] :=
    ifBreakPlusTimes[expr,OptionValue["Linebreak"],OptionValue["LinebreakThreshold"],OptionValue["LinebreakIgnore"]]//
        TeXForm//ToString//
        (* Remove pairs of brackets before calling $MFRule. *)
        ifRemoveLeftRight[OptionValue["RemoveLeftRightPair"]]//
        StringReplace[$MFRule]//
        ifBreakPlusTimes2[OptionValue["Linebreak"]]//
        deleteBlankBeforeScript//trimEmptyLine;


MFFormatKernel[string_String] :=
    Module[ {res},
        res = RunProcess[{$texfmt,"--nowrap","--tabsize","4","--stdin"},"StandardOutput",string];
        If[ Head[res]=!=String,
            Throw[res],
            (*Else*)
            res//StringTrim
        ]
    ];


(* ::Subsection:: *)
(*Helper*)


ifBreakPlusTimes//Attributes = {
    HoldFirst
};

brokenPlusTimes//Attributes = {
    HoldAll
};

ifBreakPlusTimes[expr_,True,threshold_Integer,ignoredList_List] :=
    HoldComplete[expr]//
        Replace[#,{
            HoldPattern[(head:Times|Plus)[args__]]/;
                AnyTrue[HoldComplete[args],Function[arg,leafCount[ignoredList,arg]>=threshold,HoldAllComplete]]:>
                    RuleCondition@Replace[
                        brokenPlusTimes[head,Evaluate["MF"<>ToString[head]<>"Left"],args,Evaluate["MF"<>ToString[head]<>"Right"]],
                        arg_/;leafCount[ignoredList,arg]>=threshold:>Sequence["MFLinebreak",arg,"MFLinebreak"],
                        {1}
                    ]
        },All]&//
            Replace[#,{
                brokenPlusTimes[Times,"MFTimesLeft",coefficient_?NumberQ,rest___]:>
                    brokenPlusTimes[Times,"MFTimesLeft","MFNumberLeft",HoldForm[coefficient],"MFNumberRight",rest]
            },All]&//
                Replace[#,{
                    brokenPlusTimes[head_,args__]:>HoldForm@head[args]
                },All]&//
                    ReleaseHold;

ifBreakPlusTimes[expr_,False,___] :=
    expr;


ifBreakPlusTimes2[True][string_String] :=
    string//StringReplace[{
        "\\text{MFNumberLeft} (-1) \\text{MFNumberRight}":>"-",
        "\\text{MFNumberLeft} \\left("~~Shortest[num__]~~"\\right) \\text{MFNumberRight}":>num,
        "\\text{MFNumberLeft} ("~~Shortest[num__]~~") \\text{MFNumberRight}":>num,
        "\\text{MFNumberLeft} "~~Shortest[num__]~~" \\text{MFNumberRight}":>num
    }]//StringReplace[{
        "\\text{MFLinebreak}"->"\n",
        "\\text{MFTimesLeft}"->"\n",
        "\\text{MFTimesRight}"->"\n",
        "\\text{MFPlusLeft}"->"\n",
        "\\text{MFPlusRight}"->"\n"
    }]//FixedPoint[
        StringReplace[{
            (* This is to remove the doubled bracket pair autogenerated by TeXForm. *)
            (* Notice that WhitespaceCharacter.. is used. In some cases the doubled bracket pairs should not be removed, like derivatives. *)
            (* We use the trick WhitespaceCharacter.. instead of WhitespaceCharacter... to skip these cases. *)
            left:$leftBracketP~~WhitespaceCharacter..~~"("~~Shortest[content__]~~")"~~WhitespaceCharacter..~~right:$rightBracketP/;
                braketPairQ[left,right]&&!StringContainsQ[content,"("]:>
                    left~~"\n"~~content~~"\n"~~right
        }],
        #
    ]&//FixedPoint[
        StringReplace[{
            (* Remove the double signs from MFLinebreak: "++"->"+", "+-"->"-" *)
            "+"~~spacing:WhitespaceCharacter...~~sign:"+"|"-":>spacing~~sign
        }],
        #
    ]&//FixedPoint[
        StringReplace[{
            (* Remove the plus signs at the begining/ending: "{+"->"{", "+}"->"}" *)
            prec:$leftSeparatorP~~spacing:WhitespaceCharacter...~~"+":>prec~~spacing,
            "+"~~spacing:WhitespaceCharacter...~~succ:$rightSeparatorP:>spacing~~succ,
            (* Remove the extra whitespaces. *)
            StartOfLine~~WhitespaceCharacter...~~sign:"+"|"-"~~WhitespaceCharacter...~~succ:Except[WhitespaceCharacter]:>sign~~succ
        }],
        #
    ]&;

ifBreakPlusTimes2[False][string_String] :=
    string;


leafCount//Attributes =
    {HoldAllComplete};

leafCount[_,_?Developer`HoldAtomQ] :=
    1;

leafCount[ignoredP_,Verbatim[Times][-1,rest__]] :=
    leafCount[ignoredP,Times[rest]]-1;

leafCount[ignoredP_,HoldPattern[Power[base_,-1]]] :=
    leafCount[ignoredP,base];

leafCount[ignoredP_,HoldPattern[Times[1,Power[base_,-1]]]] :=
    leafCount[ignoredP,base];

leafCount[ignoredP_,expr_]/;MatchQ[Unevaluated[expr],ignoredP] :=
    1;

leafCount[ignoredP_,head_[arg_]] :=
    leafCount[ignoredP,head]+leafCount[ignoredP,arg];

leafCount[ignoredP_,head_[args__]] :=
    leafCount[ignoredP,head]+Plus@@Map[Function[Null,leafCount[ignoredP,#],HoldAllComplete],HoldComplete[args]];


braketPairQ["(",")"] :=
    True;

braketPairQ["[","]"] :=
    True;

braketPairQ["\\{","\\}"] :=
    True;

braketPairQ["\\left(","\\right)"] :=
    True;

braketPairQ["\\left[","\\right]"] :=
    True;

braketPairQ["\\left\\{","\\right\\}"] :=
    True;

braketPairQ["{","}"] :=
    True;

(* StartOfString and EndOfString will be evaluated as empty strings. *)
braketPairQ["",""] :=
    True;

braketPairQ[__] :=
    False;


ifRemoveLeftRight[True][string_String] :=
    string//StringReplace[{
        "\\left"~~rest:"("|"["|"|"|"\\{":>rest,"\\right"~~rest:")"|"]"|"|"|"\\}":>rest
    }];

ifRemoveLeftRight[False][string_String] :=
    string;


deleteBlankBeforeScript[string_String] :=
    string//StringReplace[{
        " _"->"_"," ^"->"^"
    }];


trimEmptyLine[string_String] :=
    string//StringReplace[RegularExpression["(?m)^\\s*$\\n?"]->""]//StringTrim;


(* ::Subsection:: *)
(*End*)


End[];


(* ::Section:: *)
(*End*)


EndPackage[];
